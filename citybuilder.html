<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Builder</title>
    <style>
        /* --- General Setup & Typography --- */
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        h1,
        h2,
        h3 {
            text-align: center;
            color: #ffc107;
            margin: 10px 0;
            font-weight: 300;
        }

        hr {
            border: none;
            border-top: 1px solid #444;
            margin: 15px 0;
        }

        /* --- Main Layout --- */
        #game-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }

        #game-layout {
            display: flex;
            flex-direction: row;
            width: 98vw;
            height: 97vh;
            border: 2px solid #ffc107;
            background-color: #000;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
            border-radius: 8px;
            position: relative;
        }

        /* --- UI Panel (Left Side) --- */
        #ui-panel {
            width: 280px;
            flex-shrink: 0;
            height: 100%;
            padding: 10px 15px;
            overflow-y: auto;
            border-right: 2px solid #444;
            box-sizing: border-box;
        }

        #stats p {
            margin: 5px 0;
            font-size: 14px;
        }

        #budget-details {
            padding-left: 10px;
            border-left: 2px solid #555;
            margin-top: 5px;
        }

        #tax-rate-controls {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 5px;
            padding: 5px 0;
        }

        /* --- Map & Grid --- */
        #map-container {
            flex-grow: 1;
            height: 100%;
            position: relative;
            overflow: auto;
        }

        #grid-container {
            position: relative;
            border: 20px solid #282c34;
        }

        #grid {
            display: grid;
            cursor: default;
        }

        .grid-cell {
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* --- Buttons --- */
        .tool-btn,
        .tax-btn,
        .action-btn,
        .control-btn,
        #new-game-btn {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            padding: 8px 12px;
            margin: 0;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            border: 1px solid #777;
            box-sizing: border-box;
            text-decoration: none;
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .tool-btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }

        .tool-btn {
            width: 100%;
            background-color: #333;
            color: #fff;
            text-align: left;
            justify-content: flex-start;
            font-size: 14px;
            font-weight: 400;
            padding: 10px 8px;
            white-space: nowrap;
        }

        .tool-btn:hover {
            background-color: #444;
            border-color: #999;
        }

        .tool-btn.active {
            background-color: #ffc107;
            color: #000;
            border-color: #f39c12;
        }

        .tax-btn {
            background-color: #555;
            color: #fff;
            flex-grow: 1;
        }

        .tax-btn.active {
            background-color: #4caf50;
            border-color: #81c784;
        }

        .button-toolbar {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            gap: 8px;
        }

        .button-toolbar h3 {
            width: 100%;
            text-align: center;
            margin-bottom: 10px;
        }

        .action-btn,
        .control-btn,
        #new-game-btn {
            flex-grow: 1;
        }

        #save-btn {
            background-color: #4caf50 !important;
            color: white !important;
            border-color: #388e3c !important;
        }

        #city-log-btn {
            background-color: #ff9800 !important;
            color: white !important;
            border-color: #f57c00 !important;
        }

        #how-to-play-btn {
            background-color: #03a9f4 !important;
            color: white !important;
            border-color: #0288d1 !important;
        }

        #economy-btn {
            background-color: #673ab7 !important;
            color: white !important;
            border-color: #512da8 !important;
        }

        #new-game-btn {
            background-color: #f44336 !important;
            color: white !important;
            border-color: #d32f2f !important;
        }

        .control-btn {
            background-color: #555;
            color: white;
            font-size: 18px;
        }

        /* --- Tile & Building Styles --- */
        .grass {
            background-color: #2e7d32;
            border: 1px solid rgba(76, 175, 80, 0.2);
        }

        .road {
            background-color: #444;
            border: 1px solid #555;
        }

        .lake {
            background-color: #0077be;
            border: 1px solid #005f99;
        }

        .road-wear-1 {
            box-shadow: inset 0 0 2px 1px rgba(0, 0, 0, 0.2);
        }
        .road-wear-2 {
            box-shadow: inset 0 0 3px 1px rgba(0, 0, 0, 0.4);
        }
        .road-wear-3 {
            box-shadow: inset 0 0 4px 2px rgba(0, 0, 0, 0.6);
        }

        .build-cursor {
            cursor: cell;
        }

        .bulldoze-cursor {
            cursor: not-allowed;
        }

        .building-emoji {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .powered .building-emoji {
            text-shadow: 0 0 8px #ffeb3b, 0 0 3px #fff;
        }

        .fire-bg {
            animation: fire-bg-animation 0.5s infinite alternate;
        }

        @keyframes fire-bg-animation {
            from {
                background-color: rgba(255, 69, 0, 0.6);
            }
            to {
                background-color: rgba(255, 165, 0, 0.9);
            }
        }

        /* --- Power Lines --- */
        .power-line-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .power-line-container > div {
            position: absolute;
            background-color: #000;
        }

        .stripe-dot {
            top: 50%;
            left: 50%;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        .stripe-up {
            top: 0;
            left: 50%;
            width: 1px;
            height: 50%;
            transform: translateX(-50%);
        }
        .stripe-down {
            bottom: 0;
            left: 50%;
            width: 1px;
            height: 50%;
            transform: translateX(-50%);
        }
        .stripe-left {
            top: 50%;
            left: 0;
            width: 50%;
            height: 1px;
            transform: translateY(-50%);
        }
        .stripe-right {
            top: 50%;
            right: 0;
            width: 50%;
            height: 1px;
            transform: translateY(-50%);
        }
        
        /* --- Night Mode --- */
        #night-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(25, 25, 50, 0.2);
            z-index: 5;
            pointer-events: none;
        }

        .night-mode #night-mode-btn {
            background-color: #ffc107;
            color: #000;
        }
        .night-mode #night-overlay {
            display: block;
        }
        .night-mode .powered .building-emoji {
            text-shadow: 0 0 8px #ffeb3b, 0 0 4px #ffc107;
        }
        .night-mode .grass {
            background-color: #1b5e20;
            border-color: rgba(46, 125, 50, 0.2);
        }
        .night-mode .road {
            background-color: #212121;
            border-color: rgba(66, 66, 66, 0.2);
        }
        .night-mode .lake {
            background-color: #0d47a1;
            border-color: rgba(25, 118, 210, 0.2);
        }
        .night-mode .action-btn {
            background-color: #bdc3c7;
            color: #2c3e50;
            border-color: #95a5a6;
        }
        .night-mode .action-btn:hover {
            background-color: #ecf0f1;
        }

        /* --- Visual Effects (Clouds) --- */
        .visual-effect-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
            overflow: hidden;
        }

        .cloud,
        .cloud-shadow {
            position: absolute;
            border-radius: 50%;
            animation: drift 120s linear infinite;
        }

        .cloud {
            background-color: rgba(255, 255, 255, 0.4);
        }

        .cloud-shadow {
            background-color: rgba(0, 0, 0, 0.2);
        }

        @keyframes drift {
            from {
                transform: translateX(-200px);
            }
            to {
                transform: translateX(2400px);
            }
        }

        /* --- Minimap --- */
        #minimap-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            cursor: crosshair;
            margin: 15px 0;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            background-color: #000;
            border: 1px solid #ffc107;
        }

        #minimap-viewport {
            position: absolute;
            top: 0;
            left: 0;
            border: 1px solid #fff;
            background-color: rgba(255, 255, 255, 0.3);
            pointer-events: none;
            box-sizing: border-box;
        }

        /* --- UI Overlays (Tooltip, Ticker) --- */
        #tooltip {
            position: fixed;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            white-space: pre-wrap;
        }

        #event-ticker {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 11;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffc107;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* --- Modals --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: #2c2c2c;
            color: #f0f0f0;
            padding: 20px;
            border: 2px solid #ffc107;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
        }

        .modal-content h2 {
            color: #ffc107;
        }
        
        .modal-content li {
            padding-bottom: 10px;
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #aaaaaa;
            transition: color 0.2s ease;
        }

        .modal-close:hover {
            color: #ffc107;
        }

        .text-green {
            color: #81c784;
        }
        .text-red {
            color: #e57373;
        }

        /* --- Win Condition (Fireworks) --- */
        #fireworks-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            z-index: 5000;
            cursor: pointer;
            overflow: hidden;
        }

        #fireworks-container.active {
            display: block;
        }

        .congrats-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            width: 90%;
        }

        .congrats-text h1 {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: clamp(2.5rem, 7vw, 7rem);
            font-weight: bold;
            color: #ffc107;
            margin-bottom: 20px;
            animation: text-glow 1.5s ease-in-out infinite alternate;
        }

        .congrats-text p {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: clamp(1rem, 2.5vw, 2.2rem);
            color: #f0f0f0;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
        }

        @keyframes text-glow {
            from {
                text-shadow: 0 0 10px #ffc107, 0 0 20px #ffc107, 0 0 30px #f39c12;
            }
            to {
                text-shadow: 0 0 20px #f39c12, 0 0 35px #f39c12, 0 0 50px #f1c40f;
            }
        }
        
        .explosion {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            transform-origin: 50% 50%;
            animation: explosion-anim 1.2s ease-in-out infinite;
        }
        .explosion::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -2px;
            width: inherit;
            height: inherit;
            border-radius: 50%;
            box-shadow: 15px 23px 5px #ff0040, -11px -20px 6px #00ffb8, 23px -1px 3px #9d00ff,
                -1px -25px 5px #ffc107, 24px 21px 4px #00aeff, 11px -14px 6px #ff4d00,
                -12px -24px 3px #00ff73, 21px 11px 5px #ff00d9, -25px 14px 4px #a6ff00,
                -25px -10px 6px #ff0062, 11px 29px 3px #00ffea, -11px -7px 5px #ffc107,
                18px -10px 4px #0066ff, -23px -9px 6px #ff002f, 1px 22px 3px #a6ff00,
                -2px -23px 5px #00ffd0, 15px -25px 4px #ff00a2, -13px 25px 6px #b300ff;
        }
        @keyframes explosion-anim {
            0% { transform: scale(0.1) rotate(0deg); opacity: 1; }
            60% { opacity: 1; }
            100% { transform: scale(20) rotate(90deg); opacity: 0; }
        }
        .explosion:nth-child(1) { left: 91%; top: 32%; animation-delay: 0.8s; }
        .explosion:nth-child(2) { left: 81%; top: 69%; animation-delay: 0.2s; }
        .explosion:nth-child(3) { left: 2%; top: 60%; animation-delay: 1.1s; }
        .explosion:nth-child(4) { left: 16%; top: 8%; animation-delay: 1.5s; }
        .explosion:nth-child(5) { left: 63%; top: 5%; animation-delay: 0.1s; }
        .explosion:nth-child(6) { left: 18%; top: 68%; animation-delay: 2.3s; }
        .explosion:nth-child(7) { left: 91%; top: 88%; animation-delay: 1.7s; }
        .explosion:nth-child(8) { left: 89%; top: 22%; animation-delay: 2.1s; }
        .explosion:nth-child(9) { left: 45%; top: 45%; animation-delay: 0.5s; }
        .explosion:nth-child(10) { left: 8%; top: 23%; animation-delay: 2.8s; }
        .explosion:nth-child(11) { left: 69%; top: 82%; animation-delay: 0.9s; }
        .explosion:nth-child(12) { left: 42%; top: 12%; animation-delay: 3.1s; }

        /* --- Scrollbar --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2c2c2c;
        }

        ::-webkit-scrollbar-thumb {
            background: #007bff;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #0056b3;
        }

        * {
            scrollbar-width: thin;
            scrollbar-color: #007bff #2c2c2c;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-layout">
            <div id="ui-panel">
                <h3 id="stats-title"></h3>
                <div id="stats">
                    <p><span id="year-label"></span>: <span id="year">2025</span></p>
                    <p><span id="pop-label"></span>: <span id="population">0</span></p>
                    <p><span id="budget-label"></span>: $<span id="budget">50000</span></p>
                    <div id="budget-details">
                        <p style="color: #4caf50;"><span id="income-label"></span>: $<span id="income">0</span></p>
                        <p style="color: #f44336;"><span id="maintenance-label"></span>: $<span id="maintenance">0</span></p>
                    </div>
                </div>
                <div id="tax-rate-controls">
                    <span id="tax-label"></span>
                    <button class="tax-btn" data-rate="0.5" id="tax-low-btn"></button>
                    <button class="tax-btn active" data-rate="0.7" id="tax-med-btn"></button>
                    <button class="tax-btn" data-rate="1.0" id="tax-high-btn"></button>
                </div>
                <div id="minimap-container">
                    <div id="minimap-wrapper">
                        <canvas id="minimap-canvas"></canvas>
                        <div id="minimap-viewport"></div>
                    </div>
                </div>
                <hr>
                <h3 id="tools-title"></h3>
                <div class="tool-btn-grid">
                    <button class="tool-btn" data-tool="house" id="tool-house-btn">üè† $700</button>
                    <button class="tool-btn" data-tool="store" id="tool-store-btn">üè¨ $900</button>
                    <button class="tool-btn" data-tool="road" id="tool-road-btn">‚ûñ $25</button>
                    <button class="tool-btn" data-tool="park" id="tool-park-btn">üå≥ $450</button>
                    <button class="tool-btn" data-tool="power-plant" id="tool-power-plant-btn">‚ö°Ô∏è $10k</button>
                    <button class="tool-btn" data-tool="power-line" id="tool-power-line-btn">üîå $50</button>
                    <button class="tool-btn" data-tool="police-station" id="tool-police-station-btn">üöì $15k</button>
                    <button class="tool-btn" data-tool="fire-station" id="tool-fire-station-btn">üöí $17k</button>
                    <button class="tool-btn" data-tool="school" id="tool-school-btn">üè´ $12k</button>
                    <button class="tool-btn" data-tool="stadium" id="tool-stadium-btn">üèüÔ∏è $65k</button>
                    <button class="tool-btn" data-tool="airport" id="tool-airport-btn">‚úàÔ∏è $80k</button>
                    <button class="tool-btn" data-tool="bulldoze" id="tool-bulldoze-btn">üí£ $50</button>
                </div>
                <hr>
                <h3 id="controls-title"></h3>
                <div class="button-toolbar">
                    <button id="night-mode-btn" class="control-btn" title="Night Mode">üåô</button>
                    <button id="save-btn" class="action-btn" title="Save Game"></button>
                    <button id="city-log-btn" class="action-btn" title="City Log"></button>
                    <button id="economy-btn" class="action-btn" title="Economy"></button>
                    <button id="how-to-play-btn" class="action-btn" title="Help"></button>
                    <button id="new-game-btn" class="action-btn" title="Start a New City"></button>
                </div>
            </div>
            <div id="map-container">
                <div id="grid-container">
                    <div id="night-overlay"></div>
                    <div id="grid"></div>
                    <div id="cloud-shadow-layer" class="visual-effect-layer"></div>
                    <div id="cloud-layer" class="visual-effect-layer"></div>
                </div>
            </div>
            <div id="event-ticker"></div>
        </div>
    </div>
    <div id="tooltip"></div>
    <div id="fireworks-container">
        <div class="congrats-text">
            <h1 id="congrats-title"></h1>
            <p id="congrats-text-p"></p>
        </div>
        <div class="explosion"></div><div class="explosion"></div><div class="explosion"></div>
        <div class="explosion"></div><div class="explosion"></div><div class="explosion"></div>
        <div class="explosion"></div><div class="explosion"></div><div class="explosion"></div>
        <div class="explosion"></div><div class="explosion"></div><div class="explosion"></div>
    </div>
    <div id="how-to-play-modal" class="modal">
        <div class="modal-content"></div>
    </div>
    <div id="economy-modal" class="modal">
        <div class="modal-content">
            <span id="economy-modal-close" class="modal-close">&times;</span>
            <h2 id="economy-title"></h2>
            <div id="economy-details"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- LANGUAGE STRINGS ---
            const lang = {
                // UI Panel
                statsTitle: "City Stats",
                year: "Year",
                population: "Population",
                budget: "Budget",
                income: "Income",
                maintenance: "Maintenance",
                tax: "Taxes",
                taxLow: "Low",
                taxMedium: "Medium",
                taxHigh: "High",
                toolsTitle: "Construction Tools",
                controlsTitle: "Game Controls",
                saveGame: "üíæ Save",
                cityLog: "üìñ Log",
                economy: "üìä Economy",
                help: "‚ùì Help",
                newGame: "‚ú® New Game",
                // Ticker Messages
                welcomeBack: "Welcome back, Mayor!",
                gameSaved: "üíæ Game saved to your browser!",
                newCityBegins: "A new city has been founded!",
                taxSetTo: "Taxes set to",
                notEnoughMoney: "Not enough money!",
                notEnoughSpace: "Not enough space for this 2x2 building!",
                built: "Built",
                // Building Names
                house: "House",
                store: "Store",
                road: "Road",
                park: "Park",
                fountainPark: "Fountain Park",
                'power-plant': "Power Plant",
                'power-line': "Power Line",
                'police-station': "Police Station",
                'fire-station': "Fire Station",
                school: "School",
                stadium: "Stadium",
                airport: "Airport",
                bulldoze: "Bulldoze",
                lake: "Lake",
                // Tooltips
                tooltipPopulation: "Population",
                tooltipLoad: "Load",
                tooltipPower: "Powered",
                tooltipYes: "Yes",
                tooltipNo: "No",
                tooltipDamaged: "(Damaged!)",
                // Event Log Messages
                fireOut: "üöí The fire department has extinguished a fire!",
                buildingLostToFire: "a building was lost in the blaze!",
                insurancePayout: "üí∞ Received an insurance payout of",
                forDestroyed: "for the destroyed",
                fireStarted: "üî• A fire has broken out!",
                fireSpreads: "üî• The fire is spreading rapidly due to high population density!",
                recessionHit: "üìâ An economic recession has hit the city!",
                thunderstormDamage: "‚õàÔ∏è A thunderstorm has damaged a power plant!",
                kingKongRampage: "ü¶ç King Kong is rampaging through the city!",
                winConditionReached: "üèÜ Congratulations! You have reached",
                winConditionResidents: "residents!",
                bankruptcy: "BANKRUPTCY: The city went bankrupt in year",
                plantRepaired: "üõ†Ô∏è A damaged power plant is now fully repaired!",
                crimeComplaint: "üö® Citizens are complaining about crime in the",
                crimeAreaNW: "northwestern",
                crimeAreaNE: "northeastern",
                crimeAreaSW: "southwestern",
                crimeAreaSE: "southeastern",
                crimeArea: "part of town!",
                // Game Over & Win Screens
                congratulations: "üèÜ Congratulations! üèÜ",
                youBuiltCity: "You've built an amazing city!",
                gameOver: "GAME OVER",
                cityBankruptIn: "Your city went bankrupt in year",
                youWon: "You won the game! Thanks for playing, and remember to take a üì∑ screenshot before starting your next city!",
                restart: "‚ú® Restart",
                confirmNewGame: "Are you sure? This will delete your current city and start a new game.",
                // Help Modal
                howToPlayTitle: "How to Play City Builder",
                helpWelcome: "Welcome, Mayor! Your main goal is to build a thriving metropolis and reach a population of",
                helpGoal: "residents. But be careful ‚Äì if your city's budget drops below zero, you'll go bankrupt and the game is over!",
                helpBasicsTitle: "The Basics üíµ",
                helpBasics1: "<strong>Income:</strong> Your primary source of income is taxes, which are automatically collected from powered, occupied houses.",
                helpBasics2: "<strong>Tax Level:</strong> You can control your city's tax level! A <strong>Low</strong> level makes citizens happier and boosts population growth at the cost of revenue. A <strong>High</strong> level earns more money but will slow city growth. It's a strategic choice!",
                helpBasics3: "<strong>Expenses:</strong> Every building you place has an annual maintenance cost. As your city grows, this maintenance cost will increase, so manage your expansion carefully!",
                helpServicesTitle: "City Services & Zoning üèòÔ∏è",
                helpServicesText: "Place buildings to attract residents and keep them happy. Happy homes grow faster!",
                helpServices1: "<strong>Houses (üè†):</strong> The heart of your city. As their individual population grows, they will visually evolve into larger apartment complexes (üèòÔ∏è -> üè¢).",
                helpServices2: "<strong>Parks (üå≥):</strong> Provide a small happiness boost to nearby homes. Some rare parks even have fountains (‚õ≤Ô∏è)! (Must also have power for lights, etc.)",
                helpServices3: "<strong>Lakes (üíß):</strong> Houses built next to water get a natural happiness and growth bonus.",
                helpServices4: "<strong>Schools (üè´):</strong> Provide a significant population growth bonus to all houses within their radius. A must-have for a growing city.",
                helpServices5: "<strong>Police (üöì) & Fire Stations (üöí):</strong> Increase safety and happiness, promoting growth. Fire stations are crucial for preventing fires from spreading.",
                helpServices6: "<strong>Major Venues (üèüÔ∏è‚úàÔ∏è):</strong> The Stadium and Airport are 2x2 buildings that require a clear area. They are expensive but provide enormous benefits. The Airport, in particular, generates massive annual income. It takes many years to pay off the debt on large buildings before you start turning a profit, so you should have a solid budget that can withstand going into the red for a while.",
                helpInfraTitle: "Infrastructure ‚ö°Ô∏è",
                helpInfraText: "A city can't function without basic infrastructure.",
                helpInfra1: "<strong>Power Plants (‚ö°Ô∏è):</strong> The source of all electricity. Each plant can only support",
                helpInfra1_2: "connections. Hover over a plant to see its current load.",
                helpInfra2: "<strong>Power Lines:</strong> Use these to extend your power grid over long distances to reach remote areas. They automatically connect to adjacent buildings and other lines.",
                helpInfra3: "<strong>Roads:</strong> Provide the basic connections for your city to develop. Over time, roads in busy areas will begin to show visual signs of wear.",
                helpDisastersTitle: "Disasters & Challenges üî•",
                helpDisastersText: "Keep an eye on the event ticker at the top of the screen for news! A mayor's job is never easy.",
                helpDisasters1: "<strong>Fires (üî•):</strong> Can break out randomly in buildings. If you don't have a fire station nearby, they can spread and destroy entire neighborhoods!",
                helpDisasters2: "<strong>Thunderstorms (‚õàÔ∏è):</strong> A powerful storm can damage a power plant, shutting it down completely. Repairs are not immediate and can take several years, causing prolonged blackouts.",
                helpDisasters3: "<strong>Recession (üìâ):</strong> An economic downturn can happen at any time, temporarily cutting your city's tax income in half.",
                helpDisasters4: "<strong>King Kong (ü¶ç):</strong> Yes, really. Occasionally, a giant ape will rampage through your city, clearing a path of destruction.",
                helpGoodLuck: "Good luck, Mayor!",
                // Economy Modal
                economyTitle: "üìä Economy",
                annualNetResult: "Annual Net Result",
                incomeDistribution: "Income Distribution",
                totalIncome: "Total Income",
                expenseDistribution: "Expense Distribution",
                totalExpenses: "Total Expenses",
                // Log Modal
                cityLogTitle: "City Log",
                noLogEvents: "No events logged yet."
            };

            // --- GAME CONSTANTS & STATE ---
            const gridSize = 50;
            const cellSize = 32;
            const WIN_CONDITION_POPULATION = 80000;
            const MAX_LOG_ENTRIES = 100;
            const POWER_PLANT_CAPACITY = 200;
            const AIRPORT_INCOME_PER_CITIZEN = 0.25;
            const CUSTOMER_RADIUS = 6;
            const INCOME_PER_PERSON = 0.2;

            let gameInterval = null;
            let world = [];
            let currentTool = '';
            let budget = 50000;
            let population = 0;
            let year = 2025;
            let taxRate = 0.7;
            let isGameOver = false;
            let isDraggingMinimap = false;
            let isRecessionYear = false;
            let isDisasterAnimating = false;
            let gameLog = [];

            const costs = {
                house: 700, store: 900, park: 450, stadium: 65000, airport: 80000,
                'power-plant': 10000, 'power-line': 50, 'police-station': 15000,
                'fire-station': 17000, school: 12000, bulldoze: 50, road: 25,
            };
            const buildingEmojis = {
                house: 'üè†', store: 'üè¨', park: 'üå≥', 'power-plant': '‚ö°Ô∏è', 
                'police-station': 'üöì', 'fire-station': 'üöí', school: 'üè´', 
                stadium: 'üèüÔ∏è', airport: '‚úàÔ∏è',
            };
            const minimapColors = {
                grass: '#2e7d32', road: '#616161', lake: '#0077be', 
                building: '#f5deb3', fire: '#ff4500',
            };
            const largeBuildings = ['stadium', 'airport'];

            // --- DOM ELEMENT CACHING ---
            const gameLayout = document.getElementById('game-layout');
            if (!gameLayout) return;

            const mapContainer = document.getElementById('map-container');
            const grid = document.getElementById('grid');
            const cloudLayer = document.getElementById('cloud-layer');
            const cloudShadowLayer = document.getElementById('cloud-shadow-layer');
            const eventTicker = document.getElementById('event-ticker');
            const tooltip = document.getElementById('tooltip');
            const populationEl = document.getElementById('population');
            const budgetEl = document.getElementById('budget');
            const yearEl = document.getElementById('year');
            const incomeEl = document.getElementById('income');
            const maintenanceEl = document.getElementById('maintenance');
            const saveBtn = document.getElementById('save-btn');
            const newGameBtn = document.getElementById('new-game-btn');
            const minimapCanvas = document.getElementById('minimap-canvas');
            const minimapViewport = document.getElementById('minimap-viewport');
            const minimapCtx = minimapCanvas.getContext('2d');
            
            minimapCanvas.width = gridSize;
            minimapCanvas.height = gridSize;

            // --- CORE GAME LOGIC ---

            /**
             * Calculates the city's income and expenses for a year.
             * @param {boolean} isRecession - Whether a recession is active.
             * @returns {object} An object containing detailed income and expense data.
             */
            function getEconomyData(isRecession = false) {
                const incomeSources = {
                    houses: { count: 0, totalIncome: 0 },
                    stores: { count: 0, totalIncome: 0 },
                    airport: { count: 0, totalIncome: 0 },
                    total: 0,
                };
                const expenseSources = {
                    house: { count: 0, totalMaintenance: 0 }, store: { count: 0, totalMaintenance: 0 },
                    park: { count: 0, totalMaintenance: 0 }, 'power-plant': { count: 0, totalMaintenance: 0 },
                    'police-station': { count: 0, totalMaintenance: 0 }, 'fire-station': { count: 0, totalMaintenance: 0 },
                    school: { count: 0, totalMaintenance: 0 }, stadium: { count: 0, totalMaintenance: 0 },
                    airport: { count: 0, totalMaintenance: 0 }, total: 0,
                };

                // Maintenance costs scale up as the city grows to add a late-game challenge.
                const baseMaintenanceRate = 0.035;
                const scalingFactor = Math.pow(population / 70000, 2);
                const maintenanceRate = baseMaintenanceRate + (scalingFactor * 0.15);

                world.forEach((cell, index) => {
                    if (cell.building) {
                        const type = cell.building.type;
                        const cost = costs[type] || 0;
                        const maintenance = cost * maintenanceRate;
                        
                        // Calculate expenses (only count main tile of 2x2 buildings)
                        if (expenseSources[type] && !cell.building.isPart) {
                            expenseSources[type].count++;
                            expenseSources[type].totalMaintenance += maintenance;
                            expenseSources.total += maintenance;
                        }

                        // Calculate income from powered buildings
                        if (cell.building.powered) {
                            if (type === 'house') {
                                let tax = Math.floor(cell.building.population * taxRate);
                                if (isRecession) tax = Math.floor(tax / 2);
                                incomeSources.houses.count++;
                                incomeSources.houses.totalIncome += tax;
                                incomeSources.total += tax;
                            } else if (type === 'store') {
                                let nearbyPopulation = 0;
                                getNeighbors(index, CUSTOMER_RADIUS).forEach((nIndex) => {
                                    const neighborCell = world[nIndex];
                                    if (neighborCell.building?.type === 'house' && neighborCell.building.powered) {
                                        nearbyPopulation += neighborCell.building.population;
                                    }
                                });
                                const storeIncome = Math.floor(nearbyPopulation * INCOME_PER_PERSON);
                                incomeSources.stores.count++;
                                incomeSources.stores.totalIncome += storeIncome;
                                incomeSources.total += storeIncome;
                            } else if (type === 'airport' && !cell.building.isPart) {
                                const airportRevenue = Math.floor(population * AIRPORT_INCOME_PER_CITIZEN);
                                incomeSources.airport.count++;
                                incomeSources.airport.totalIncome += airportRevenue;
                                incomeSources.total += airportRevenue;
                            }
                        }
                    }
                });
                return { incomeSources, expenseSources };
            }

            /**
             * Main game loop function, simulates one year passing.
             */
            function simulateYear() {
                isRecessionYear = false;

                updateCrimeLevels();
                handleRepairs();
                handleDisasters();
                distributePower();
                updateRoadWear();
                
                let currentPopulation = 0;

                // Update population for each house
                world.forEach((cell, index) => {
                    if (cell.building?.type === 'house') {
                        if (cell.building.powered && !cell.onFire) {
                            const hasPark = getNeighbors(index, 3).some((n) => world[n].building?.type === 'park' && world[n].building.powered);
                            const hasRoad = getNeighbors(index, 1).some((n) => world[n].base === 'road');
                            const parkAndRoadBonus = (hasPark ? 1.0 : 0) + (hasRoad ? 1.5 : 0) + (hasPark && hasRoad ? 0.5 : 0);
                            const schoolBonus = getNeighbors(index, 8).some((n) => world[n].building?.type === 'school' && world[n].building.powered) ? 4 : 0;
                            const stadiumBonus = getNeighbors(index, 20).some((n) => world[n].building?.type === 'stadium' && world[n].building.powered) ? 12 : 0;
                            const lakeBonus = getNeighbors(index, 1).some((n) => world[n].base === 'lake') ? 3.5 : 0;
                            const crimePenalty = cell.crimeLevel > 0 && cell.building.population >= 30 ? -15 : 0;
                            
                            let taxBonus = 0;
                            if (taxRate < 0.6) taxBonus = 2;   // Low tax encourages growth
                            if (taxRate > 0.8) taxBonus = -25; // High tax heavily discourages growth
                            
                            const randomFactor = Math.random() * 0.08;
                            let growth = randomFactor + parkAndRoadBonus + schoolBonus + stadiumBonus + lakeBonus + taxBonus + crimePenalty;

                            cell.building.population += growth;
                            if (cell.building.population > 150) cell.building.population = 150; // Cap population per house
                        } else {
                            // Population declines in unpowered or burning houses
                            cell.building.population = Math.max(0, cell.building.population - 25);
                        }
                        currentPopulation += Math.floor(cell.building.population);
                    }
                });

                // Update budget
                const { incomeSources, expenseSources } = getEconomyData(isRecessionYear);
                const yearlyIncome = incomeSources.total;
                const maintenanceCosts = expenseSources.total;
                
                population = currentPopulation;
                budget += yearlyIncome - maintenanceCosts;
                incomeEl.textContent = Math.floor(yearlyIncome).toLocaleString();
                maintenanceEl.textContent = Math.floor(maintenanceCosts).toLocaleString();
                year++;

                updateUI();
                updateMinimap();

                // Check for win/loss conditions
                if (population >= WIN_CONDITION_POPULATION && !isGameOver) {
                    isGameOver = true;
                    logEvent(`${lang.winConditionReached} ${WIN_CONDITION_POPULATION.toLocaleString()} ${lang.winConditionResidents}`);
                    const fireworks = document.getElementById('fireworks-container');
                    fireworks.classList.add('active');
                    fireworks.addEventListener('click', () => {
                        fireworks.classList.remove('active');
                        handleGameOver(lang.youWon);
                    }, { once: true });
                }

                if (budget < 0 && !isGameOver) {
                    isGameOver = true;
                    logEvent(`${lang.bankruptcy} ${year}.`);
                    handleGameOver(`${lang.gameOver}\n\n${lang.cityBankruptIn} ${year}!`);
                }
            }
            
            /**
             * Handles random disasters like fires, recessions, etc.
             */
            function handleDisasters() {
                // Handle ongoing fires
                world.forEach((cell, index) => {
                    if (cell.onFire) {
                        const fireStationNearby = getNeighbors(index, 20).some(
                            (n) => world[n].building?.type === 'fire-station' && world[n].building.powered
                        );

                        if (fireStationNearby) {
                            cell.onFire = false;
                            logEvent(lang.fireOut);
                        } else {
                            // If no fire station, building might be destroyed or fire might spread
                            if (Math.random() < 0.9) { // 90% chance of being destroyed
                                const buildingType = cell.building?.type;
                                logEvent(`üî• ${lang[buildingType] || 'A building'} ${lang.buildingLostToFire}`);
                                if (buildingType) {
                                    const originalCost = costs[buildingType] || 0;
                                    const insurancePayout = Math.floor(originalCost * 0.6);
                                    budget += insurancePayout;
                                    if (insurancePayout > 0) {
                                        logEvent(`${lang.insurancePayout} $${insurancePayout.toLocaleString()} ${lang.forDestroyed} ${lang[buildingType]}.`);
                                    }
                                    if (largeBuildings.includes(buildingType)) {
                                        clear2x2Building(cell.building.originIndex);
                                    } else {
                                        cell.building = null;
                                    }
                                }
                                cell.onFire = false;
                            } else { // 10% chance of spreading
                                getNeighbors(index, 1).forEach((nIndex) => {
                                    const neighborCell = world[nIndex];
                                    if (neighborCell.building && !neighborCell.onFire) {
                                        neighborCell.onFire = true;
                                    }
                                });
                            }
                        }
                    }
                });

                // Chance of a new disaster starting
                const disasterChance = 0.01 + (population / WIN_CONDITION_POPULATION) * 0.035;
                if (Math.random() < disasterChance) {
                    const possibleDisasters = ['recession'];
                    if (world.some((cell) => cell.building)) possibleDisasters.push('fire', 'kingkong');
                    if (world.some((c) => c.building?.type === 'power-plant' && !c.building.isDamaged)) possibleDisasters.push('thunderstorm');
                    if (possibleDisasters.length === 0) return;
                    
                    const chosenDisaster = possibleDisasters[Math.floor(Math.random() * possibleDisasters.length)];

                    if (chosenDisaster === 'fire') {
                        const buildings = world.map((c, i) => (c.building ? i : -1)).filter((i) => i !== -1);
                        if (buildings.length > 0) {
                            const fireIndex = buildings[Math.floor(Math.random() * buildings.length)];
                            world[fireIndex].onFire = true;
                            logEvent(lang.fireStarted);
                            // Chance for fire to spread immediately in dense cities
                            if (population > 40000 && Math.random() < 0.3) {
                                logEvent(lang.fireSpreads);
                                getNeighbors(fireIndex, 1).forEach((nIndex) => {
                                    const neighborCell = world[nIndex];
                                    if (neighborCell.building && !neighborCell.onFire) {
                                        neighborCell.onFire = true;
                                    }
                                });
                            }
                        }
                    } else if (chosenDisaster === 'recession') {
                        isRecessionYear = true;
                        logEvent(lang.recessionHit);
                    } else if (chosenDisaster === 'thunderstorm') {
                        const powerPlants = world
                            .map((c, i) => (c.building?.type === 'power-plant' && !c.building.isDamaged ? i : -1))
                            .filter((i) => i !== -1);
                        if (powerPlants.length > 0) {
                            const targetPlantIndex = powerPlants[Math.floor(Math.random() * powerPlants.length)];
                            world[targetPlantIndex].building.isDamaged = true;
                            logEvent(lang.thunderstormDamage);
                        }
                    } else if (chosenDisaster === 'kingkong') {
                        logEvent(lang.kingKongRampage);
                        kingKongRampage();
                    }
                }
            }

            // --- INITIALIZATION & SETUP ---

            /**
             * Main function to initialize the game state and UI.
             */
            function init() {
                const gridPixelSize = gridSize * cellSize;
                const gridContainer = document.getElementById('grid-container');
                gridContainer.style.width = `${gridPixelSize}px`;
                gridContainer.style.height = `${gridPixelSize}px`;
                
                grid.style.gridTemplateColumns = `repeat(${gridSize}, ${cellSize}px)`;
                grid.style.gridTemplateRows = `repeat(${gridSize}, ${cellSize}px)`;
                grid.style.fontSize = `${Math.floor(cellSize * 0.75)}px`;
                
                document.querySelectorAll('.visual-effect-layer').forEach((layer) => {
                    layer.style.width = `${gridPixelSize}px`;
                    layer.style.height = `${gridPixelSize}px`;
                });

                loadWorld();
                createGrid();
                updateStaticUIText();
                setupEventListeners();
                updateMinimapViewport();
                createClouds();
                distributePower(true);
                updateUI();
                updateMinimap();

                if (gameInterval) clearInterval(gameInterval);
                gameInterval = setInterval(simulateYear, 10000);
            }

            /**
             * Starts the game, checking for saved data.
             */
            function startGame() {
                init();
                const savedGameExists = localStorage.getItem('cityBuilderSave') !== null;
                if (savedGameExists) {
                    showTickerMessage(lang.welcomeBack);
                } else {
                    showHelp();
                }
            }

            /**
             * Sets up all the game's event listeners.
             */
            function setupEventListeners() {
                grid.addEventListener('click', onCellClick);
                grid.addEventListener('mouseover', onCellMouseOver);
                grid.addEventListener('mouseout', onCellMouseOut);
                
                document.addEventListener('mousemove', onMouseMove);
                mapContainer.addEventListener('scroll', updateMinimapViewport);

                const minimapWrapper = document.getElementById('minimap-wrapper');
                minimapWrapper.addEventListener('mousedown', (e) => {
                    isDraggingMinimap = true;
                    handleMinimapNavigation(e);
                });
                document.addEventListener('mousemove', (e) => {
                    if (isDraggingMinimap) handleMinimapNavigation(e);
                });
                document.addEventListener('mouseup', () => { isDraggingMinimap = false; });
                
                // Tool buttons
                document.querySelectorAll('.tool-btn').forEach((btn) => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach((b) => b.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        currentTool = btn.dataset.tool;
                    });
                });

                // Tax buttons
                document.querySelectorAll('.tax-btn').forEach((btn) => {
                    btn.addEventListener('click', (e) => {
                        taxRate = parseFloat(e.currentTarget.dataset.rate);
                        document.querySelectorAll('.tax-btn').forEach((b) => b.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        showTickerMessage(`${lang.taxSetTo} ${e.currentTarget.textContent.trim()}.`);
                    });
                });
                
                // Control buttons
                document.getElementById('night-mode-btn').addEventListener('click', () => {
                    gameLayout.classList.toggle('night-mode');
                });

                saveBtn.addEventListener('click', () => {
                    if (isGameOver) return;
                    try {
                        const data = JSON.stringify({
                            world, budget, population, year, isGameOver, gameLog, taxRate,
                        });
                        localStorage.setItem('cityBuilderSave', data);
                        showTickerMessage(lang.gameSaved);
                    } catch (e) {
                        console.error('Error saving game:', e);
                        alert('Could not save the game. Your browser might be out of storage space or in private mode.');
                    }
                });

                newGameBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (confirm(lang.confirmNewGame)) {
                        localStorage.removeItem('cityBuilderSave');
                        budget = 50000;
                        population = 0;
                        year = 2025;
                        isGameOver = false;
                        gameLog = [];
                        isRecessionYear = false;
                        isDisasterAnimating = false;
                        taxRate = 0.7;

                        document.querySelectorAll('.tax-btn').forEach((b) => b.classList.remove('active'));
                        document.querySelector('.tax-btn[data-rate="0.7"]').classList.add('active');
                        
                        saveBtn.disabled = false;
                        newGameBtn.textContent = lang.newGame;

                        initEmptyWorld();
                        distributePower(true);
                        updateUI();
                        updateMinimap();

                        if (gameInterval) clearInterval(gameInterval);
                        gameInterval = setInterval(simulateYear, 10000);
                        showTickerMessage(lang.newCityBegins);
                    }
                });
                
                document.getElementById('city-log-btn').addEventListener('click', showLog);
                document.getElementById('how-to-play-btn').addEventListener('click', showHelp);
                document.getElementById('economy-btn').addEventListener('click', showEconomyWindow);
                document.getElementById('economy-modal-close').addEventListener('click', () => {
                    document.getElementById('economy-modal').style.display = 'none';
                });
                
                // Close modals by clicking outside of them
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.style.display = 'none';
                        }
                    });
                });

                // Prevent page scroll when scrolling map at edges
                mapContainer.addEventListener('wheel', (e) => {
                    const atLeftEdge = mapContainer.scrollLeft === 0 && e.deltaX < 0;
                    const atRightEdge = mapContainer.scrollWidth - mapContainer.clientWidth - mapContainer.scrollLeft < 1 && e.deltaX > 0;
                    if (atLeftEdge || atRightEdge) {
                        e.preventDefault();
                    }
                });
            }

            /**
             * Creates the initial empty world state with lakes.
             */
            function initEmptyWorld() {
                world = Array(gridSize * gridSize).fill(null).map(() => ({
                    base: 'grass', building: null, hasPowerLine: false,
                    onFire: false, roadWear: 0, crimeLevel: 0,
                }));
                gameLog = [];
                generateLakes();
            }
            
            /**
             * Populates the grid with lakes for a new map.
             */
            function generateLakes() {
                const numLakes = Math.floor(Math.random() * 5) + 3;
                for (let i = 0; i < numLakes; i++) {
                    const lakeSize = Math.floor(Math.random() * 100) + 50;
                    let x = Math.floor(Math.random() * gridSize);
                    let y = Math.floor(Math.random() * gridSize);
                    for (let j = 0; j < lakeSize; j++) {
                        const index = y * gridSize + x;
                        if (world[index]) {
                            world[index].base = 'lake';
                        }
                        // Random walk to grow the lake
                        x += Math.floor(Math.random() * 3) - 1;
                        y += Math.floor(Math.random() * 3) - 1;
                        x = Math.max(0, Math.min(x, gridSize - 1));
                        y = Math.max(0, Math.min(y, gridSize - 1));
                    }
                }
            }
            
            /**
             * Loads game state from localStorage.
             */
            function loadWorld() {
                const worldDataJson = localStorage.getItem('cityBuilderSave');
                if (worldDataJson) {
                    try {
                        const data = JSON.parse(worldDataJson);
                        if (data.world && data.world.length > 0) {
                            // Map saved data to ensure all properties exist for new versions
                            world = data.world.map(cell => ({
                                base: cell.base || 'grass',
                                building: cell.building ? { ...cell.building } : null,
                                hasPowerLine: cell.hasPowerLine || false,
                                onFire: cell.onFire || false,
                                roadWear: cell.roadWear || 0,
                                crimeLevel: cell.crimeLevel || 0,
                            }));
                            budget = data.budget;
                            population = data.population;
                            year = data.year;
                            isGameOver = data.isGameOver || false;
                            gameLog = data.gameLog || [];
                            taxRate = data.taxRate || 0.7;

                            // Update tax button UI
                            document.querySelectorAll('.tax-btn').forEach((btn) => {
                                btn.classList.remove('active');
                                if (parseFloat(btn.dataset.rate) === taxRate) {
                                    btn.classList.add('active');
                                }
                            });
                        } else {
                            initEmptyWorld();
                        }
                    } catch (e) {
                        console.error("Could not load save data", e);
                        initEmptyWorld();
                    }
                } else {
                    initEmptyWorld();
                }
            }


            // --- UI & RENDERING ---

            /**
             * Populates the grid div with cell elements.
             */
            function createGrid() {
                grid.innerHTML = '';
                for (let i = 0; i < gridSize * gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.dataset.index = i;
                    cell.className = 'grid-cell grass';
                    grid.appendChild(cell);
                }
            }
            
            /**
             * Draws the entire game grid based on the `world` array.
             */
            function updateUI() {
                budgetEl.textContent = Math.floor(budget).toLocaleString();
                populationEl.textContent = population.toLocaleString();
                yearEl.textContent = year;

                for (let i = 0; i < world.length; i++) {
                    const cellEl = grid.children[i];
                    const cellData = world[i];

                    // Reset cell content and classes
                    cellEl.innerHTML = '';
                    cellEl.className = `grid-cell ${cellData.base}`;
                    
                    if (currentTool) {
                        cellEl.classList.add(currentTool === 'bulldoze' ? 'bulldoze-cursor' : 'build-cursor');
                    }

                    if (cellData.base === 'road' && cellData.roadWear > 0) {
                        cellEl.classList.add(`road-wear-${cellData.roadWear}`);
                    }

                    const emojiSpan = document.createElement('span');
                    emojiSpan.className = 'building-emoji';

                    if (cellData.building) {
                        let emoji = buildingEmojis[cellData.building.type] || '';
                        // Special emoji variations
                        if (cellData.building.type === 'park' && cellData.building.hasFountain) emoji = '‚õ≤Ô∏è';
                        if (cellData.building.type === 'house') {
                            if (cellData.building.population > 100) emoji = 'üè¢';
                            else if (cellData.building.population > 50) emoji = 'üèòÔ∏è';
                        }
                        emojiSpan.textContent = emoji;
                        if (cellData.building.powered) {
                            cellEl.classList.add('powered');
                        }
                    }
                    cellEl.appendChild(emojiSpan);

                    if (cellData.hasPowerLine) {
                        const lineContainer = document.createElement('div');
                        lineContainer.className = 'power-line-container';
                        const x = i % gridSize;
                        const y = Math.floor(i / gridSize);
                        const connections = {
                            up: y > 0 && isPowerConnection(i - gridSize),
                            down: y < gridSize - 1 && isPowerConnection(i + gridSize),
                            left: x > 0 && isPowerConnection(i - 1),
                            right: x < gridSize - 1 && isPowerConnection(i + 1)
                        };
                        let hasAnyConnection = false;
                        if (connections.up) { const d = document.createElement('div'); d.className = 'stripe-up'; lineContainer.appendChild(d); hasAnyConnection = true; }
                        if (connections.down) { const d = document.createElement('div'); d.className = 'stripe-down'; lineContainer.appendChild(d); hasAnyConnection = true; }
                        if (connections.left) { const d = document.createElement('div'); d.className = 'stripe-left'; lineContainer.appendChild(d); hasAnyConnection = true; }
                        if (connections.right) { const d = document.createElement('div'); d.className = 'stripe-right'; lineContainer.appendChild(d); hasAnyConnection = true; }
                        if (hasAnyConnection) {
                            const d = document.createElement('div'); d.className = 'stripe-dot'; lineContainer.appendChild(d);
                        }
                        cellEl.appendChild(lineContainer);
                    }

                    if (cellData.onFire) {
                        cellEl.classList.add('fire-bg');
                        emojiSpan.textContent = 'üî•';
                    }
                }
            }

            /**
             * Sets the static text content of the UI based on the `lang` object.
             */
            function updateStaticUIText() {
                document.getElementById('stats-title').textContent = lang.statsTitle;
                document.getElementById('year-label').innerHTML = `üìÖ ${lang.year}`;
                document.getElementById('pop-label').innerHTML = `üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ${lang.population}`;
                document.getElementById('budget-label').innerHTML = `üí∞ ${lang.budget}`;
                document.getElementById('income-label').textContent = lang.income;
                document.getElementById('maintenance-label').textContent = lang.maintenance;
                document.getElementById('tax-label').textContent = `${lang.tax}:`;
                document.getElementById('tax-low-btn').title = `${lang.taxSetTo} ${lang.taxLow}`;
                document.getElementById('tax-low-btn').textContent = lang.taxLow;
                document.getElementById('tax-med-btn').title = `${lang.taxSetTo} ${lang.taxMedium}`;
                document.getElementById('tax-med-btn').textContent = lang.taxMedium;
                document.getElementById('tax-high-btn').title = `${lang.taxSetTo} ${lang.taxHigh}`;
                document.getElementById('tax-high-btn').textContent = lang.taxHigh;
                document.getElementById('tools-title').textContent = lang.toolsTitle;
                document.getElementById('controls-title').textContent = lang.controlsTitle;
                document.getElementById('tool-house-btn').title = lang.house;
                document.getElementById('tool-store-btn').title = lang.store;
                document.getElementById('tool-road-btn').title = lang.road;
                document.getElementById('tool-park-btn').title = lang.park;
                document.getElementById('tool-power-plant-btn').title = lang['power-plant'];
                document.getElementById('tool-power-line-btn').title = lang['power-line'];
                document.getElementById('tool-police-station-btn').title = lang['police-station'];
                document.getElementById('tool-fire-station-btn').title = lang['fire-station'];
                document.getElementById('tool-school-btn').title = lang.school;
                document.getElementById('tool-stadium-btn').title = lang.stadium;
                document.getElementById('tool-airport-btn').title = lang.airport;
                document.getElementById('tool-bulldoze-btn').title = lang.bulldoze;
                saveBtn.textContent = lang.saveGame;
                document.getElementById('city-log-btn').textContent = lang.cityLog;
                document.getElementById('economy-btn').textContent = lang.economy;
                document.getElementById('how-to-play-btn').textContent = lang.help;
                newGameBtn.textContent = lang.newGame;
                document.getElementById('economy-title').textContent = lang.economyTitle;
                document.getElementById('congrats-title').textContent = lang.congratulations;
                document.getElementById('congrats-text-p').textContent = lang.youBuiltCity;
            }
            
            /**
             * Creates decorative clouds that drift across the screen.
             */
            function createClouds() {
                if (!cloudLayer) return;
                cloudLayer.innerHTML = '';
                cloudShadowLayer.innerHTML = '';
                for (let i = 0; i < 10; i++) {
                    const cloud = document.createElement('div');
                    cloud.className = 'cloud';
                    const size = 100 + Math.random() * 150;
                    cloud.style.width = `${size}px`;
                    cloud.style.height = `${size * 0.6}px`;
                    cloud.style.top = `${Math.random() * (gridSize * cellSize)}px`;
                    cloud.style.animationDelay = `${Math.random() * -120}s`;
                    cloudLayer.appendChild(cloud);

                    const shadow = cloud.cloneNode();
                    shadow.className = 'cloud-shadow';
                    shadow.style.top = `${parseFloat(cloud.style.top) + 20}px`;
                    shadow.style.left = `-20px`; // Shadow offset
                    cloudShadowLayer.appendChild(shadow);
                }
            }


            // --- PLAYER ACTIONS ---

            /**
             * Handles clicks on the game grid to place or remove items.
             * @param {Event} e - The click event.
             */
            function onCellClick(e) {
                const cellElement = e.target.closest('.grid-cell');
                if (!cellElement) return;
                
                const index = parseInt(cellElement.dataset.index);
                if (isDisasterAnimating || !currentTool || isNaN(index) || isGameOver || budget < 0) return;

                const cost = costs[currentTool] || 0;
                if (budget < cost) {
                    alert(lang.notEnoughMoney);
                    return;
                }
                
                let cell = world[index];
                if (cell.base === 'lake' && !['power-line', 'bulldoze'].includes(currentTool)) return;
                
                let buildingPlaced = false;

                if (largeBuildings.includes(currentTool)) {
                    if (check2x2Area(index)) {
                        budget -= cost;
                        place2x2Building(index, currentTool);
                        buildingPlaced = true;
                    } else {
                        alert(lang.notEnoughSpace);
                    }
                } else if (currentTool === 'road') {
                    if (cell.base === 'grass' && !cell.building) {
                        budget -= cost;
                        cell.base = 'road';
                        cell.roadWear = 0;
                    }
                } else if (currentTool === 'power-line') {
                    if (!cell.hasPowerLine && !cell.building) {
                        budget -= cost;
                        cell.hasPowerLine = true;
                    }
                } else if (currentTool === 'bulldoze') {
                    if (cell.building || cell.hasPowerLine || cell.base === 'road') {
                        budget -= cost;
                        if (cell.building) {
                            if (largeBuildings.includes(cell.building.type)) {
                                clear2x2Building(cell.building.originIndex);
                            } else {
                                cell.building = null;
                            }
                            if (cell.onFire) cell.onFire = false;
                        } else if (cell.hasPowerLine) {
                            cell.hasPowerLine = false;
                        } else if (cell.base === 'road') {
                            cell.base = 'grass';
                            cell.roadWear = 0;
                        }
                    }
                } else { // Standard 1x1 buildings
                    if (!cell.building && cell.base === 'grass' && !cell.hasPowerLine) {
                        budget -= cost;
                        let buildingData = { type: currentTool, population: 0, powered: false };
                        if (currentTool === 'park') buildingData.hasFountain = Math.random() < 0.1;
                        if (currentTool === 'power-plant') buildingData.powerLoad = 0;
                        cell.building = buildingData;
                        buildingPlaced = true;
                    }
                }

                if (buildingPlaced) {
                    showTickerMessage(`${lang.built} ${lang[currentTool]}.`);
                }
                distributePower(true); // Redraw power lines after change
                updateUI();
            }


            // --- UTILITY & HELPER FUNCTIONS ---

            /**
             * Checks if a tile is a valid connection point for a power line.
             * @param {number} index - The index of the cell to check.
             * @returns {boolean} True if it's a valid power connection.
             */
            const isPowerConnection = (index) => {
                const neighbor = world[index];
                // Parks don't conduct power, they only consume it.
                return neighbor.hasPowerLine || (neighbor.building && neighbor.building.type !== 'park');
            };
            
            /**
             * Simulates the spread of electricity from power plants.
             */
            function distributePower() {
                // Reset power state for all buildings
                world.forEach((cell) => {
                    if (cell.building) {
                        cell.building.powered = false;
                        if (cell.building.type === 'power-plant' && !cell.building.isPart) {
                            cell.building.powerLoad = 0;
                        }
                    }
                });
                
                const alreadyPowered = new Set();
                const powerPlants = world
                    .map((c, i) => (c.building?.type === 'power-plant' && !c.building.isPart ? i : -1))
                    .filter((i) => i !== -1);
                
                // Perform a Breadth-First Search (BFS) from each power plant
                powerPlants.forEach((plantIndex) => {
                    const plant = world[plantIndex].building;
                    if (plant.isDamaged) {
                        plant.powerLoad = 0;
                        return;
                    }
                    
                    const q = [plantIndex];
                    const poweredByThisPlant = new Set();
                    const visitedInThisSearch = new Set([plantIndex]);
                    
                    if (!alreadyPowered.has(plantIndex)) {
                        poweredByThisPlant.add(plantIndex);
                        alreadyPowered.add(plantIndex);
                    }

                    let head = 0;
                    while (head < q.length) {
                        const currentIndex = q[head++];
                        if (poweredByThisPlant.size >= POWER_PLANT_CAPACITY) break;
                        
                        getNeighbors(currentIndex).forEach((neighborIndex) => {
                            if (!visitedInThisSearch.has(neighborIndex)) {
                                visitedInThisSearch.add(neighborIndex);
                                const neighborCell = world[neighborIndex];
                                // Power spreads through buildings (except parks) and power lines
                                if (neighborCell.building || neighborCell.hasPowerLine) {
                                    q.push(neighborIndex);
                                    if (!alreadyPowered.has(neighborIndex) && poweredByThisPlant.size < POWER_PLANT_CAPACITY) {
                                        poweredByThisPlant.add(neighborIndex);
                                        alreadyPowered.add(neighborIndex);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Apply power to all connected buildings
                    poweredByThisPlant.forEach((index) => {
                        if (world[index].building) {
                            world[index].building.powered = true;
                        }
                    });
                    
                    if (plant) {
                        plant.powerLoad = poweredByThisPlant.size;
                    }
                });
            }

            /**
             * Returns an array of indices for a cell's neighbors.
             * @param {number} index - The center cell's index.
             * @param {number} [range=1] - The search range (1 for adjacent, 2 for a 5x5 area, etc.).
             * @returns {number[]} An array of neighbor indices.
             */
            function getNeighbors(index, range = 1) {
                const neighbors = [];
                const x = index % gridSize;
                const y = Math.floor(index / gridSize);
                for (let i = -range; i <= range; i++) {
                    for (let j = -range; j <= range; j++) {
                        if (i === 0 && j === 0) continue;
                        const nx = x + j;
                        const ny = y + i;
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                            neighbors.push(ny * gridSize + nx);
                        }
                    }
                }
                return neighbors;
            }

            function showTickerMessage(message) {
                eventTicker.textContent = message;
                eventTicker.style.opacity = 1;
                setTimeout(() => {
                    eventTicker.style.opacity = 0;
                }, 5000);
            }

            function logEvent(message) {
                gameLog.unshift(`${lang.year} ${year}: ${message}`);
                if (gameLog.length > MAX_LOG_ENTRIES) {
                    gameLog.pop();
                }
                showTickerMessage(message);
            }
            
            // --- MODAL & OVERLAY FUNCTIONS ---

            function showLog() {
                const modal = document.getElementById('how-to-play-modal');
                const modalContent = modal.querySelector('.modal-content');
                modalContent.innerHTML = `<span class="modal-close">&times;</span><h2>${lang.cityLogTitle}</h2>`;
                const logList = document.createElement('ul');
                logList.style.cssText = 'list-style-type: none; padding: 0;';
                if (gameLog.length === 0) {
                    logList.innerHTML = `<li>${lang.noLogEvents}</li>`;
                } else {
                    gameLog.forEach((entry) => {
                        const li = document.createElement('li');
                        li.textContent = entry;
                        li.style.cssText = 'border-bottom: 1px solid #444; padding: 8px 0;';
                        logList.appendChild(li);
                    });
                }
                modalContent.appendChild(logList);
                modalContent.querySelector('.modal-close').addEventListener('click', () => { modal.style.display = 'none'; });
                modal.style.display = 'flex';
            }

            function showHelp() {
                const modal = document.getElementById('how-to-play-modal');
                const modalContent = modal.querySelector('.modal-content');
                modalContent.innerHTML = `<span class="modal-close">&times;</span>
                    <h2>${lang.howToPlayTitle}</h2>
                    <p>${lang.helpWelcome} <strong>${WIN_CONDITION_POPULATION.toLocaleString()}</strong> ${lang.helpGoal}</p>
                    <h4>${lang.helpBasicsTitle}</h4>
                    <ul><li>${lang.helpBasics1}</li><li>${lang.helpBasics2}</li><li>${lang.helpBasics3}</li></ul>
                    <h4>${lang.helpServicesTitle}</h4>
                    <p>${lang.helpServicesText}</p>
                    <ul><li>${lang.helpServices1}</li><li>${lang.helpServices2}</li><li>${lang.helpServices3}</li><li>${lang.helpServices4}</li><li>${lang.helpServices5}</li><li>${lang.helpServices6}</li></ul>
                    <h4>${lang.helpInfraTitle}</h4>
                    <p>${lang.helpInfraText}</p>
                    <ul><li>${lang.helpInfra1} ${POWER_PLANT_CAPACITY} ${lang.helpInfra1_2}</li><li>${lang.helpInfra2}</li><li>${lang.helpInfra3}</li></ul>
                    <h4>${lang.helpDisastersTitle}</h4>
                    <p>${lang.helpDisastersText}</p>
                    <ul><li>${lang.helpDisasters1}</li><li>${lang.helpDisasters2}</li><li>${lang.helpDisasters3}</li><li>${lang.helpDisasters4}</li></ul>
                    <p style="text-align: center; margin-top: 20px;">${lang.helpGoodLuck}</p>`;
                modalContent.querySelector('.modal-close').addEventListener('click', () => { modal.style.display = 'none'; });
                modal.style.display = 'flex';
            }
            
            function showEconomyWindow() {
                const modal = document.getElementById('economy-modal');
                const economyDetails = document.getElementById('economy-details');
                const { incomeSources, expenseSources } = getEconomyData(false);
                
                let incomeHtml = `<hr><h4>${lang.incomeDistribution}</h4><ul>`;
                Object.keys(incomeSources).forEach((key) => {
                    if (key !== 'total' && incomeSources[key].count > 0) {
                        const name = key.charAt(0).toUpperCase() + key.slice(1);
                        const translatedName = { Houses: lang.house, Stores: lang.store, Airport: lang.airport };
                        incomeHtml += `<li>${translatedName[name] || name} (${incomeSources[key].count}): <strong>$${Math.floor(incomeSources[key].totalIncome).toLocaleString()}</strong></li>`;
                    }
                });
                incomeHtml += `</ul><p class="text-green"><strong>${lang.totalIncome}: $${Math.floor(incomeSources.total).toLocaleString()}</strong></p><hr>`;
                
                let expenseHtml = `<h4>${lang.expenseDistribution}</h4><ul>`;
                Object.keys(expenseSources).forEach((key) => {
                    if (key !== 'total' && expenseSources[key].count > 0) {
                        expenseHtml += `<li>${lang[key] || key} (${expenseSources[key].count}): <strong>$${Math.floor(expenseSources[key].totalMaintenance).toLocaleString()}</strong></li>`;
                    }
                });
                expenseHtml += `</ul><p class="text-red"><strong>${lang.totalExpenses}: $${Math.floor(expenseSources.total).toLocaleString()}</strong></p><hr>`;
                
                const netProfit = incomeSources.total - expenseSources.total;
                const netHtml = `<h3>${lang.annualNetResult}: <strong class="${netProfit >= 0 ? 'text-green' : 'text-red'}">$${Math.floor(netProfit).toLocaleString()}</strong></h3>`;
                
                economyDetails.innerHTML = netHtml + incomeHtml + expenseHtml;
                modal.style.display = 'flex';
            }
            
            function handleGameOver(message) {
                clearInterval(gameInterval);
                setTimeout(() => {
                    alert(message);
                    saveBtn.disabled = true;
                    newGameBtn.textContent = lang.restart;
                    newGameBtn.style.backgroundColor = '#4CAF50';
                }, 100);
            }


            // --- MINIMAP & TOOLTIP FUNCTIONS ---
            
            function updateMinimap() {
                minimapCtx.clearRect(0, 0, gridSize, gridSize);
                for (let i = 0; i < world.length; i++) {
                    const cell = world[i];
                    let color = minimapColors[cell.base];
                    if (cell.building) {
                        color = cell.building.powered ? minimapColors.building : '#8d6e63'; // Dimmer color for unpowered
                    }
                    if (cell.onFire) {
                        color = minimapColors.fire;
                    }
                    minimapCtx.fillStyle = color;
                    minimapCtx.fillRect(i % gridSize, Math.floor(i / gridSize), 1, 1);
                }
            }

            function handleMinimapNavigation(e) {
                const rect = minimapCanvas.getBoundingClientRect();
                const xPercent = (e.clientX - rect.left) / rect.width;
                const yPercent = (e.clientY - rect.top) / rect.height;
                const gridContainer = document.getElementById('grid-container');

                if (!gridContainer || !mapContainer || gridContainer.scrollWidth === 0 || gridContainer.scrollHeight === 0) return;

                mapContainer.scrollLeft = (xPercent * gridContainer.scrollWidth) - (mapContainer.clientWidth / 2);
                mapContainer.scrollTop = (yPercent * gridContainer.scrollHeight) - (mapContainer.clientHeight / 2);
            }

            function updateMinimapViewport() {
                const gridContainer = document.getElementById('grid-container');
                if (gridContainer.scrollWidth === 0 || gridContainer.scrollHeight === 0) return;

                const mapWidth = minimapCanvas.offsetWidth;
                const mapHeight = minimapCanvas.offsetHeight;

                const xRatio = mapContainer.clientWidth / gridContainer.scrollWidth;
                const yRatio = mapContainer.clientHeight / gridContainer.scrollHeight;

                minimapViewport.style.width = `${(xRatio * mapWidth) - 2}px`; // -2 for border
                minimapViewport.style.height = `${(yRatio * mapHeight) - 2}px`; // -2 for border
                minimapViewport.style.left = `${(mapContainer.scrollLeft / gridContainer.scrollWidth) * mapWidth}px`;
                minimapViewport.style.top = `${(mapContainer.scrollTop / gridContainer.scrollHeight) * mapHeight}px`;
            }

            function onCellMouseOver(e) {
                const cellElement = e.target.closest('.grid-cell');
                if (!cellElement) return;

                const index = parseInt(cellElement.dataset.index);
                if (isNaN(index)) return;

                const cellData = world[index];
                let text = '';

                if (cellData.building) {
                    text = lang[cellData.building.type] || cellData.building.type;
                    if (cellData.building.type === 'park' && cellData.building.hasFountain) text = lang.fountainPark;
                    if (cellData.building.type === 'house') text += `\n${lang.tooltipPopulation}: ${Math.floor(cellData.building.population)}`;
                    if (cellData.building.type === 'power-plant') text += `\n${lang.tooltipLoad}: ${cellData.building.powerLoad || 0} / ${cellData.building.isDamaged ? 0 : POWER_PLANT_CAPACITY}`;
                    text += `\n${lang.tooltipPower}: ${cellData.building.powered ? lang.tooltipYes : lang.tooltipNo}`;
                    if (cellData.building.isDamaged) text += `\n${lang.tooltipDamaged}`;
                } else if (cellData.hasPowerLine) {
                    text = lang['power-line'];
                } else if (cellData.base === 'road') {
                    text = lang.road;
                } else if (cellData.base === 'lake') {
                    text = lang.lake;
                }

                if (cellData.onFire) text = `üî• ${text} üî•`;

                if (text) {
                    tooltip.innerText = text;
                    tooltip.style.display = 'block';
                }
            }

            function onCellMouseOut() {
                tooltip.style.display = 'none';
            }

            function onMouseMove(e) {
                let newX = e.clientX + 15;
                let newY = e.clientY + 15;
                // Keep tooltip within the viewport
                if (newX + tooltip.offsetWidth > window.innerWidth) newX = e.clientX - tooltip.offsetWidth - 15;
                if (newY + tooltip.offsetHeight > window.innerHeight) newY = e.clientY - tooltip.offsetHeight - 15;
                tooltip.style.left = `${newX}px`;
                tooltip.style.top = `${newY}px`;
            }

            // --- MISCELLANEOUS GAME MECHANICS ---

            function updateRoadWear() {
                world.forEach((cell, i) => {
                    if (cell.base === 'road') {
                        let nearbyPop = 0;
                        getNeighbors(i, 2).forEach((nIndex) => {
                            const nCell = world[nIndex];
                            if (nCell.building?.type === 'house' && nCell.building.population) {
                                nearbyPop += nCell.building.population;
                            }
                        });
                        if (nearbyPop > 800) cell.roadWear = 3;
                        else if (nearbyPop > 300) cell.roadWear = 2;
                        else if (nearbyPop > 50) cell.roadWear = 1;
                        else cell.roadWear = 0;
                    }
                });
            }
            
            function handleRepairs() {
                world.forEach((cell) => {
                    // Damaged power plants have a chance to be repaired each year
                    if (cell.building?.type === 'power-plant' && cell.building.isDamaged && Math.random() < 0.25) {
                        cell.building.isDamaged = false;
                        logEvent(lang.plantRepaired);
                    }
                });
            }

            function updateCrimeLevels() {
                // Crime is a late-game mechanic
                if (year < 2075) {
                    world.forEach((cell) => (cell.crimeLevel = 0));
                    return;
                }
                
                const quadrantCrime = { nw: 0, ne: 0, sw: 0, se: 0 };
                const mid = gridSize / 2;

                world.forEach((cell, index) => {
                    cell.crimeLevel = 0;
                    // Houses far from a police station generate crime
                    if (cell.building?.type === 'house' &&
                        !getNeighbors(index, 30).some((n) => world[n].building?.type === 'police-station' && world[n].building.powered)) {
                        cell.crimeLevel = 1;
                        const x = index % gridSize;
                        const y = Math.floor(index / gridSize);
                        if (y < mid && x < mid) quadrantCrime.nw++;
                        else if (y < mid && x >= mid) quadrantCrime.ne++;
                        else if (y >= mid && x < mid) quadrantCrime.sw++;
                        else quadrantCrime.se++;
                    }
                });
                
                // Log a complaint if one quadrant is particularly crime-ridden
                const maxCrimeQuadrant = Object.keys(quadrantCrime).reduce((a, b) => (quadrantCrime[a] > quadrantCrime[b] ? a : b));
                if (quadrantCrime[maxCrimeQuadrant] > 4) {
                    const quadrantNames = { nw: lang.crimeAreaNW, ne: lang.crimeAreaNE, sw: lang.crimeAreaSW, se: lang.crimeAreaSE };
                    logEvent(`${lang.crimeComplaint} ${quadrantNames[maxCrimeQuadrant] || maxCrimeQuadrant} ${lang.crimeArea}`);
                }
            }
            
            function kingKongRampage() {
                isDisasterAnimating = true;
                let x = Math.floor(Math.random() * gridSize);
                let y = Math.floor(Math.random() * gridSize);
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Up, Down, Left, Right
                const [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
                const steps = 15;

                for (let i = 0; i < steps; i++) {
                    const currentX = x + dx * i;
                    const currentY = y + dy * i;
                    setTimeout(() => {
                        if (currentX < 0 || currentX >= gridSize || currentY < 0 || currentY >= gridSize) {
                            return;
                        }
                        const index = currentY * gridSize + currentX;
                        const cell = world[index];
                        // Destroy whatever is in his path
                        if (cell.building && largeBuildings.includes(cell.building.type)) {
                            clear2x2Building(cell.building.originIndex);
                        }
                        world[index] = { base: 'grass', building: null, hasPowerLine: false, onFire: false, roadWear: 0, crimeLevel: 0 };
                        
                        const cellEl = grid.children[index];
                        if (cellEl) {
                            cellEl.className = 'grid-cell grass';
                            cellEl.innerHTML = '<span class="building-emoji">ü¶ç</span>';
                        }
                    }, i * 250); // Animate the path of destruction
                }

                setTimeout(() => {
                    isDisasterAnimating = false;
                    updateUI(); // Redraw the grid after the rampage
                }, steps * 250 + 500);
            }

            // --- 2x2 BUILDING HELPERS ---
            
            function check2x2Area(index) {
                const x = index % gridSize;
                const y = Math.floor(index / gridSize);
                if (x + 1 >= gridSize || y + 1 >= gridSize) return false; // Check bounds
                const indices = [index, index + 1, index + gridSize, index + gridSize + 1];
                return indices.every((i) => world[i].base === 'grass' && !world[i].building && !world[i].hasPowerLine);
            }

            function place2x2Building(index, type) {
                const indices = [index, index + 1, index + gridSize, index + gridSize + 1];
                if (indices.every(i => i >= 0 && i < world.length)) {
                    const buildingData = { type: type, powered: false, originIndex: index };
                    if (type === 'power-plant') {
                        buildingData.powerLoad = 0;
                    }
                    indices.forEach((i, part) => {
                        // Mark other parts of the building so they can't be interacted with individually
                        world[i].building = { ...buildingData, isPart: part > 0 };
                    });
                }
            }

            function clear2x2Building(originIndex) {
                const indices = [originIndex, originIndex + 1, originIndex + gridSize, originIndex + gridSize + 1];
                indices.forEach((i) => {
                    if (i >= 0 && i < world.length && world[i]?.building) {
                        world[i].building = null;
                    }
                });
            }

            // --- START THE GAME ---
            startGame();
        });
    </script>
</body>
</html>